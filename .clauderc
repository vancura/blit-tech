# Blit–Tech WebGPU Game Engine - Project Rules

You are working on Blit–Tech, a lightweight WebGPU retro game engine for
TypeScript inspired by RetroBlit. It provides pixel-perfect 2D rendering with
a clean, fantasy-console-style API.

---

> **Note**: This file is auto-generated from .cursor/rules/*.mdc files.
> To update these rules, edit the .mdc files and run: `pnpm run sync-rules`

---

# Blit–Tech Project Rules

Blit–Tech is a lightweight WebGPU retro game engine for TypeScript, inspired by RetroBlit.
It provides pixel-perfect 2D rendering with a clean, fantasy-console-style API.

## CRITICAL RULES

### No Emoji

NEVER use emoji in:

- Source code (comments, strings, identifiers)
- Documentation (markdown files, JSDoc)
- Commit messages
- Pull request titles and descriptions
- Error messages or log output

This rule has no exceptions. Use plain text descriptions instead.

### Integer Coordinates

All rendering uses integer positions. The engine is designed for pixel-perfect graphics:

- Use `Vector2i` for all positions and sizes
- Use `Rect2i` for all rectangular regions
- Values are automatically floored to integers
- Never use floating-point coordinates for rendering

### Performance First

The engine targets 60 FPS with thousands of sprites:

- Minimize allocations in update/render loops
- Reuse buffers and objects where possible
- Batch draw calls (sprites batched by texture)
- Avoid creating objects in hot paths - use object pools or pre-allocated arrays

## Architecture

### Public API

All engine functionality is accessed through the static `BT` namespace:

```typescript
// Correct - use BT namespace
BT.clear(Color32.black());
BT.drawSprite(sheet, srcRect, destPos);
BT.cameraSet(new Vector2i(100, 50));

// Wrong - never access internal classes directly
BTAPI.instance.renderer.drawSprite(...);
```

### Game Interface

Games implement `IBlitTechGame`:

```typescript
interface IBlitTechGame {
    queryHardware(): HardwareSettings;  // Called first, configure display
    initialize(): Promise<boolean>;      // Load assets, return true if ready
    update(): void;                       // Fixed timestep (60 FPS default)
    render(): void;                       // Variable rate rendering
}
```

### Internal Architecture

- `BTAPI` - Internal singleton managing all subsystems
- `Renderer` - WebGPU rendering with dual pipelines (primitives + sprites)
- Asset classes (`SpriteSheet`, `BitmapFont`) with lazy GPU resource creation

## Core Types

### Vector2i

Integer 2D vector for positions and sizes:

- Constructor auto-floors values: `new Vector2i(1.7, 2.3)` becomes `(1, 2)`
- Has `width`/`height` aliases for `x`/`y`
- Arithmetic methods return new instances: `pos.add(offset)`
- Static constructors: `Vector2i.zero()`, `Vector2i.one()`, etc.

### Rect2i

Integer rectangle for regions:

- Properties: `x`, `y`, `width`, `height`
- Computed: `min`, `max`, `center`, `position`, `size`
- Methods: `contains()`, `intersects()`, `intersection()`, `intersectionDepth()`

### Color32

32-bit RGBA color (0-255 per channel):

- Constructor auto-clamps values
- Conversions: `toFloat32Array()`, `toUint32()`, `toHex()`
- Static colors: `Color32.white()`, `Color32.black()`, `Color32.red()`, etc.
- Parsing: `Color32.fromHex('#FF0000')`, `Color32.fromRGB(255, 0, 0)`

## Rendering

### Dual Pipeline Architecture

The renderer uses two separate WebGPU pipelines:

1. **Primitives Pipeline** - Colored geometry (pixels, lines, rectangles)
   - Vertex format: position (x, y) + color (r, g, b, a)
   - Max vertices: 100,000 per frame
   - Used by: `drawPixel`, `drawLine`, `drawRect`, `drawRectFill`

2. **Sprites Pipeline** - Textured quads with tinting
   - Vertex format: position + UV + tint color
   - Max vertices: 50,000 per frame (4096 quads)
   - Nearest-neighbor sampling for pixel-perfect rendering
   - Automatic batching by texture

### Drawing Order

Draw calls are rendered in order within each frame:

1. `BT.clear()` sets background color
2. Primitives and sprites interleave based on call order
3. Frame ends with `endFrame()` which flushes all batches

### Camera System

Camera offset affects all drawing:

```typescript
BT.cameraSet(new Vector2i(100, 50));  // Scroll world
BT.cameraGet();                        // Get current offset
BT.cameraReset();                      // Reset to (0, 0)
```

## Assets

### SpriteSheet

Load images as GPU textures:

```typescript
const sheet = await SpriteSheet.load('sprites.png');
BT.drawSprite(sheet, new Rect2i(0, 0, 16, 16), new Vector2i(100, 100));
```

- Textures created lazily on first use
- Format: `rgba8unorm`
- Sampling: nearest-neighbor (pixel-perfect)

### BitmapFont

Custom `.btfont` JSON format:

```typescript
const font = await BitmapFont.load('fonts/MyFont.btfont');
BT.printFont(font, new Vector2i(10, 10), 'Hello World', Color32.white());
```

- Variable-width glyphs with per-character offsets
- Unicode support
- Embedded (base64) or external texture references

## Future: Palette System

The engine will support VGA Mode 13h style palettized rendering:

- R8Uint index framebuffer (256 colors max)
- Palette as uniform buffer (256 x vec4<f32>)
- Palette effects: rotation/cycling, fade, swap, flash
- Configurable sizes: 256, 128, 64, 32, 16, 8, 4 colors
- Dual-mode: RGBA and indexed sprites can coexist

When implementing palette features:

- Index framebuffer separate from RGBA framebuffer
- Palette lookup in fragment shader
- Palette changes don't require redrawing - just update uniform

## Code Style

Enforced by Biome and ESLint:

- **Indent**: 4 spaces
- **Line width**: 120 characters max
- **Quotes**: Single quotes for strings
- **Semicolons**: Always required
- **Trailing commas**: Always (including function parameters)
- **Arrow parens**: Always use parentheses

### Imports

Use type imports for type-only imports:

```typescript
// Correct
import type { HardwareSettings } from './IBlitTechGame';
import { Vector2i, Rect2i } from '../utils/Vector2i';

// Wrong
import { HardwareSettings } from './IBlitTechGame';  // If only used as type
```

### JSDoc

Required for public APIs:

```typescript
/**
 * Draws a sprite from a sprite sheet at the specified position.
 * @param sheet - The sprite sheet containing the source texture
 * @param srcRect - Source rectangle in the sprite sheet (pixels)
 * @param destPos - Destination position on screen
 * @param tint - Optional tint color (default: white)
 */
export function drawSprite(
    sheet: SpriteSheet,
    srcRect: Rect2i,
    destPos: Vector2i,
    tint?: Color32
): void;
```

### Code Organization

Structure source files for maximum readability and maintainability. Organize code logically with clear sections.

#### File Structure

Organize files in a logical flow from top to bottom:

1. **Imports/Requires** - All external dependencies at the top
2. **Configuration** - Setup, constants, command-line flags, environment checks
3. **Module State** - Module-level variables and state
4. **Helper/Utility Functions** - Pure functions and utilities (defined before use)
5. **Event Handlers** - Functions that handle specific events
6. **Lifecycle Functions** - Initialization, cleanup, main entry points
7. **Exports** - Public API exports (if applicable)

#### Region Comments

Use `// #region` and `// #endregion` comments to create collapsible sections in editors (VS Code/Cursor). This provides a `#pragma region`-like experience:

```javascript
// #region Configuration

app.commandLine.appendSwitch('enable-webgpu');

// #endregion

// #region Helper Functions

function isInternalUrl(url) {
    // ...
}

// #endregion

// #region Event Handlers

function handleNavigation(event, url) {
    // ...
}

// #endregion
```

**Benefits:**

- Collapsible sections in the editor for better navigation
- Clear visual separation of code sections
- Improved code readability and maintainability
- Standard practice in JavaScript/TypeScript projects

**Guidelines:**

- Use descriptive region names that clearly indicate the section's purpose
- Group related functionality together within regions
- Keep regions focused - split large sections if they become too broad
- Place helper functions before functions that use them
- End regions with `// #endregion` on its own line

**Example Structure:**

```javascript
const { app, BrowserWindow } = require('electron');

// #region Configuration

// Platform-specific setup
if (process.platform === 'linux') {
    // ...
}

// #endregion

// #region Module State

let mainWindow;

// #endregion

// #region Helper Functions

function isInternalUrl(url) {
    return url.startsWith('file://');
}

// #endregion

// #region Event Handlers

function handleNavigation(event, url) {
    if (!isInternalUrl(url)) {
        event.preventDefault();
    }
}

// #endregion

// #region App Lifecycle

app.whenReady().then(() => {
    createWindow();
});

// #endregion
```

## Directory Structure

```text
src/
  BlitTech.ts          # Public API (BT namespace exports)
  main.ts              # Dev entry point
  core/
    BTAPI.ts           # Internal singleton
    IBlitTechGame.ts   # Game interface
  render/
    Renderer.ts        # WebGPU renderer
  assets/
    AssetLoader.ts     # Image loading with caching
    SpriteSheet.ts     # GPU texture wrapper
    BitmapFont.ts      # Bitmap font system
  utils/
    Vector2i.ts        # Integer 2D vector
    Rect2i.ts          # Integer rectangle
    Color32.ts         # 32-bit color
```

## Git Commits

### Conventional Commits

All commits must follow the Conventional Commits format:

```text
<type>(<scope>): <description>

[optional body]

[optional footer(s)]
```

**Rules:**

- Header (first line) max 100 characters
- Subject must be lowercase
- Subject must not end with period

**Types:**

- `feat` - New feature
- `fix` - Bug fix
- `docs` - Documentation only
- `style` - Formatting, no code change
- `refactor` - Code change that neither fixes a bug nor adds a feature
- `perf` - Performance improvement
- `test` - Adding or updating tests
- `build` - Build system or dependencies
- `ci` - CI configuration
- `chore` - Other changes (e.g., tooling)

**Suggested Scopes:**

- `renderer` - Rendering system
- `camera` - Camera system
- `assets` - Asset loading
- `api` - Public API (BT namespace)
- `utils` - Utility classes
- `examples` - Example projects
- `ci` - CI/CD configuration
- `docs` - Documentation

**Examples:**

```text
feat(renderer): add circle primitive drawing
fix(assets): handle missing texture gracefully
perf(renderer): reduce buffer uploads per frame
docs: update API reference section
```

### Signed-Off Commits

All commits must include a sign-off line (DCO - Developer Certificate of Origin):

```text
Signed-off-by: Your Name <your.email@example.com>
```

Use `git commit -s` to automatically add the sign-off.

### AI-Assisted Commits

When AI tools are used to write code or commit messages, include the AI trailer:

```text
feat(palette): implement color cycling effect

Add palette rotation with configurable speed and range.
Supports both forward and reverse cycling directions.

Signed-off-by: Your Name <your.email@example.com>

Co-Authored-By: Claude <noreply@anthropic.com>
```

This applies to any AI assistance (Cursor, Claude, GitHub Copilot, etc.).

## Common Mistakes to Avoid

1. **Using floating-point coordinates** - Always use Vector2i/Rect2i
2. **Creating objects in render loop** - Pre-allocate or use pools
3. **Accessing BTAPI directly** - Use BT namespace
4. **Forgetting async in initialize()** - Asset loading is async
5. **Using emoji** - Never allowed anywhere
6. **Skipping JSDoc** - Required for public functions/classes
7. **Using `any` type** - Use proper types or `unknown`

---

# TypeScript Conventions

This document covers TypeScript-specific patterns and style requirements for Blit–Tech.

## Compiler Configuration

The project uses strict TypeScript. Key settings from `tsconfig.json`:

```json
{
    "compilerOptions": {
        "target": "ES2022",
        "module": "ESNext",
        "strict": true,
        "noUnusedLocals": true,
        "noUnusedParameters": true,
        "noFallthroughCasesInSwitch": true,
        "noUncheckedIndexedAccess": true,
        "exactOptionalPropertyTypes": true,
        "noImplicitReturns": true,
        "noImplicitOverride": true,
        "verbatimModuleSyntax": true
    }
}
```

All these checks are enabled - code must pass all of them.

## Type Imports

Always use type-only imports for types:

```typescript
// Correct - type import
import type { HardwareSettings, IBlitTechGame } from './IBlitTechGame';
import { Vector2i, Rect2i } from '../utils/Vector2i';

// Wrong - importing types as values
import { HardwareSettings } from './IBlitTechGame';
```

Use `import type` when:

- Importing interfaces
- Importing type aliases
- Importing types only used in type positions

## Type Safety

### Avoid `any`

Never use `any` unless absolutely necessary:

```typescript
// Bad
function process(data: any): any {
    return data.value;
}

// Good
function process<T extends { value: unknown }>(data: T): T['value'] {
    return data.value;
}

// Also acceptable for truly unknown data
function process(data: unknown): number {
    if (typeof data === 'object' && data !== null && 'value' in data) {
        return data.value as number;
    }
    throw new Error('Invalid data');
}
```

### Null Checks

Use strict null checks. Handle null/undefined explicitly:

```typescript
// Bad - might be undefined
const value = array[index];
console.log(value.property);

// Good - check first (noUncheckedIndexedAccess)
const value = array[index];
if (value !== undefined) {
    console.log(value.property);
}

// Also good - use optional chaining
console.log(array[index]?.property);
```

### Non-null Assertions

Avoid `!` assertions. If you must use them, add a comment:

```typescript
// Bad - unexplained assertion
const element = document.getElementById('game')!;

// Better - with justification
// Element guaranteed to exist in index.html
const element = document.getElementById('game')!;

// Best - runtime check
const element = document.getElementById('game');
if (!element) {
    throw new Error('Game canvas not found');
}
```

## Naming Conventions

### Classes and Interfaces

- Classes: PascalCase - `SpriteSheet`, `BitmapFont`, `Renderer`
- Interfaces: PascalCase with `I` prefix for contracts - `IBlitTechGame`
- Type aliases: PascalCase - `HardwareSettings`, `GlyphData`

```typescript
// Interface for implementation contract
interface IBlitTechGame {
    update(): void;
    render(): void;
}

// Type alias for data shape
type HardwareSettings = {
    displaySize: Vector2i;
    targetFPS: number;
};

// Class implementing interface
class MyGame implements IBlitTechGame {
    update(): void { /* ... */ }
    render(): void { /* ... */ }
}
```

### Variables and Functions

- Variables: camelCase - `vertexCount`, `spriteSheet`
- Functions: camelCase - `drawSprite`, `loadImage`
- Constants: UPPER_SNAKE_CASE - `MAX_VERTICES`, `FLIP_H`
- Private members: camelCase (no underscore prefix) - `private vertexData`

```typescript
// Constants
const MAX_BATCH_SIZE = 4096;
const VERTEX_SIZE = 8;

// Class with naming conventions
class Renderer {
    private device: GPUDevice;
    private vertexBuffer: GPUBuffer;
    private vertexCount = 0;

    drawSprite(sheet: SpriteSheet, rect: Rect2i, pos: Vector2i): void {
        // ...
    }
}
```

### Parameters

- Use descriptive names, not abbreviations
- Unused parameters: prefix with underscore

```typescript
// Good - descriptive names
function createTexture(device: GPUDevice, width: number, height: number): GPUTexture;

// Good - unused parameter marked
function handleEvent(_event: Event, data: string): void {
    console.log(data);
}

// Bad - unclear abbreviations
function createTex(d: GPUDevice, w: number, h: number): GPUTexture;
```

## JSDoc Requirements

Public APIs require JSDoc documentation:

### Functions

```typescript
/**
 * Draws a filled rectangle on the screen.
 * @param rect - The rectangle bounds in screen coordinates
 * @param color - Fill color
 */
export function drawRectFill(rect: Rect2i, color: Color32): void {
    // implementation
}
```

### Classes

```typescript
/**
 * Manages GPU textures for sprite rendering.
 * Handles lazy texture creation and UV coordinate calculation.
 */
export class SpriteSheet {
    /**
     * Loads a sprite sheet from an image URL.
     * @param url - Path to the image file
     * @returns Promise resolving to the loaded sprite sheet
     * @throws Error if the image fails to load
     */
    static async load(url: string): Promise<SpriteSheet> {
        // implementation
    }
}
```

### Interfaces

```typescript
/**
 * Game lifecycle interface.
 * Implement this to create a Blit–Tech game.
 */
export interface IBlitTechGame {
    /**
     * Called once at startup to configure hardware.
     * @returns Hardware configuration for the engine
     */
    queryHardware(): HardwareSettings;

    /**
     * Called after hardware initialization.
     * Load assets and initialize game state here.
     * @returns Promise resolving to true if initialization succeeded
     */
    initialize(): Promise<boolean>;
}
```

## Async Patterns

### Async/Await

Use async/await for all asynchronous code:

```typescript
// Good - async/await
async function loadAssets(): Promise<void> {
    const sheet = await SpriteSheet.load('sprites.png');
    const font = await BitmapFont.load('font.btfont');
    // ...
}

// Bad - raw promises
function loadAssets(): Promise<void> {
    return SpriteSheet.load('sprites.png')
        .then((sheet) => {
            return BitmapFont.load('font.btfont');
        })
        .then((font) => {
            // ...
        });
}
```

### Parallel Loading

Load independent assets in parallel:

```typescript
// Good - parallel loading
async function initialize(): Promise<boolean> {
    const [spriteSheet, font, music] = await Promise.all([
        SpriteSheet.load('sprites.png'),
        BitmapFont.load('font.btfont'),
        AudioAsset.load('music.mp3'),
    ]);
    // All loaded
    return true;
}

// Bad - sequential when parallel is possible
async function initialize(): Promise<boolean> {
    const spriteSheet = await SpriteSheet.load('sprites.png');
    const font = await BitmapFont.load('font.btfont');
    const music = await AudioAsset.load('music.mp3');
    return true;
}
```

### Error Handling

Handle async errors appropriately:

```typescript
// In initialize() - let errors propagate
async initialize(): Promise<boolean> {
    try {
        this.spriteSheet = await SpriteSheet.load('sprites.png');
        return true;
    } catch (error) {
        console.error('Failed to load sprites:', error);
        return false;
    }
}

// Or use Promise.allSettled for partial success
const results = await Promise.allSettled([
    SpriteSheet.load('required.png'),
    SpriteSheet.load('optional.png'),
]);
```

## Error Handling

### Custom Errors

Use descriptive error messages:

```typescript
// Good - descriptive error
if (!navigator.gpu) {
    throw new Error(
        'WebGPU is not supported in this browser. ' +
        'Please use Chrome 113+, Edge 113+, or Safari 18+.'
    );
}

// Bad - vague error
if (!navigator.gpu) {
    throw new Error('GPU error');
}
```

### Guard Clauses

Use early returns for validation:

```typescript
// Good - guard clauses
function drawSprite(sheet: SpriteSheet | null, rect: Rect2i, pos: Vector2i): void {
    if (!sheet) {
        console.warn('drawSprite called with null sheet');
        return;
    }

    if (rect.width <= 0 || rect.height <= 0) {
        return; // Nothing to draw
    }

    // Main logic here
}

// Bad - deeply nested
function drawSprite(sheet: SpriteSheet | null, rect: Rect2i, pos: Vector2i): void {
    if (sheet) {
        if (rect.width > 0 && rect.height > 0) {
            // Main logic buried in nesting
        }
    }
}
```

## Code Organization

### File Structure

One primary export per file:

```typescript
// Vector2i.ts - single class export
export class Vector2i {
    // ...
}

// Also export related utilities
export function vector2iFromAngle(angle: number, length: number): Vector2i {
    // ...
}
```

### Import Order

Imports sorted by ESLint (simple-import-sort):

```typescript
// 1. External packages
import type { GPUDevice, GPUTexture } from '@webgpu/types';

// 2. Internal absolute imports
import { BTAPI } from './core/BTAPI';
import type { IBlitTechGame } from './core/IBlitTechGame';

// 3. Relative imports
import { Color32 } from '../utils/Color32';
import { Vector2i } from '../utils/Vector2i';
```

### Export Patterns

Use named exports (not default):

```typescript
// Good - named exports
export class SpriteSheet { }
export function loadImage(url: string): Promise<HTMLImageElement> { }

// Bad - default exports
export default class SpriteSheet { }
```

## Performance Considerations

### Avoid Object Creation in Loops

```typescript
// Bad - creates new Vector2i every frame
update(): void {
    this.position = this.position.add(new Vector2i(1, 0));
}

// Good - reuse objects
private velocity = new Vector2i(1, 0);
update(): void {
    this.position = this.position.add(this.velocity);
}

// Best - mutate in place (for performance-critical code)
private position = { x: 0, y: 0 };
update(): void {
    this.position.x += 1;
}
```

### Use TypedArrays for GPU Data

```typescript
// Good - TypedArray for GPU upload
private vertices = new Float32Array(MAX_VERTICES * STRIDE);

// Bad - regular array (requires conversion)
private vertices: number[] = [];
```

### Const Assertions

Use `as const` for literal types:

```typescript
// Good - const assertion
const SPRITE_FLAGS = {
    FLIP_H: 1 << 0,
    FLIP_V: 1 << 1,
    ROT_90: 1 << 2,
} as const;

type SpriteFlag = typeof SPRITE_FLAGS[keyof typeof SPRITE_FLAGS];
```

---

# WebGPU Conventions

This document covers WebGPU-specific patterns and best practices for the Blit–Tech engine.

## Buffer Management

### Typed Arrays

Use typed arrays for GPU data:

```typescript
// Vertex data - pre-allocated
private vertexData = new Float32Array(MAX_VERTICES * VERTEX_SIZE);
private vertexCount = 0;

// Reset each frame, don't reallocate
beginFrame(): void {
    this.vertexCount = 0;
}
```

### Buffer Strategy

- Pre-allocate buffers at initialization
- Reuse buffers across frames
- Upload data with `device.queue.writeBuffer()`
- Check capacity before adding vertices

```typescript
private hasSpaceForQuad(): boolean {
    return (this.vertexCount + 6) <= MAX_VERTICES;
}

addQuad(...): void {
    if (!this.hasSpaceForQuad()) {
        console.warn('Buffer full, quad dropped');
        return;
    }
    // Add vertices...
}
```

### Uniform Buffers

- Use for data that changes per-frame (resolution, camera)
- Keep small (WebGPU has alignment requirements)
- Update with `writeBuffer()` at frame start

```typescript
// Resolution uniform (vec2<f32>)
const resolutionData = new Float32Array([width, height]);
device.queue.writeBuffer(this.resolutionBuffer, 0, resolutionData);
```

## Texture Handling

### Texture Creation

Standard texture setup for sprites:

```typescript
const texture = device.createTexture({
    size: [width, height],
    format: 'rgba8unorm',
    usage: GPUTextureUsage.TEXTURE_BINDING |
           GPUTextureUsage.COPY_DST |
           GPUTextureUsage.RENDER_ATTACHMENT,
});
```

### Texture Formats

| Use Case | Format | Notes |
|----------|--------|-------|
| Sprites/images | `rgba8unorm` | Standard 32-bit color |
| Index buffer (palette) | `r8uint` | 8-bit palette indices |
| Render target | `rgba8unorm` | Same as swap chain |

### Sampling

Pixel-perfect rendering requires nearest-neighbor:

```typescript
const sampler = device.createSampler({
    magFilter: 'nearest',
    minFilter: 'nearest',
    addressModeU: 'clamp-to-edge',
    addressModeV: 'clamp-to-edge',
});
```

Never use `linear` filtering for pixel art.

### Texture Upload

Upload from ImageBitmap:

```typescript
device.queue.copyExternalImageToTexture(
    { source: imageBitmap },
    { texture: gpuTexture },
    [width, height]
);
```

## Shader Conventions (WGSL)

### Binding Groups

Organize bindings by update frequency:

- **Group 0**: Per-frame uniforms (resolution, camera)
- **Group 1**: Per-material resources (textures, samplers)

```wgsl
// Group 0 - frame uniforms
@group(0) @binding(0) var<uniform> resolution: vec2<f32>;

// Group 1 - texture resources
@group(1) @binding(0) var texSampler: sampler;
@group(1) @binding(1) var texture: texture_2d<f32>;
```

### Vertex Shader Pattern

Standard vertex transformation:

```wgsl
struct VertexInput {
    @location(0) position: vec2<f32>,
    @location(1) color: vec4<f32>,
}

struct VertexOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) color: vec4<f32>,
}

@vertex
fn vs_main(input: VertexInput) -> VertexOutput {
    var output: VertexOutput;

    // Convert pixel coords to clip space (-1 to 1)
    let normalized = input.position / resolution * 2.0 - 1.0;
    output.position = vec4<f32>(normalized.x, -normalized.y, 0.0, 1.0);
    output.color = input.color;

    return output;
}
```

### Fragment Shader Pattern

Basic textured fragment:

```wgsl
@fragment
fn fs_main(input: VertexOutput) -> @location(0) vec4<f32> {
    let texColor = textureSample(texture, texSampler, input.texCoord);
    return texColor * input.color;  // Apply tint
}
```

### Palette Lookup (Future)

For indexed color rendering:

```wgsl
@group(0) @binding(0) var<uniform> palette: array<vec4<f32>, 256>;
@group(1) @binding(0) var indexTexture: texture_2d<u32>;

@fragment
fn fs_main(input: VertexOutput) -> @location(0) vec4<f32> {
    let index = textureLoad(indexTexture, vec2<i32>(input.texCoord), 0).r;
    return palette[index];
}
```

## Pipeline Management

### Render Pipeline Setup

Standard pipeline configuration:

```typescript
const pipeline = device.createRenderPipeline({
    layout: 'auto',
    vertex: {
        module: shaderModule,
        entryPoint: 'vs_main',
        buffers: [vertexBufferLayout],
    },
    fragment: {
        module: shaderModule,
        entryPoint: 'fs_main',
        targets: [{
            format: presentationFormat,
            blend: {
                color: {
                    srcFactor: 'src-alpha',
                    dstFactor: 'one-minus-src-alpha',
                    operation: 'add',
                },
                alpha: {
                    srcFactor: 'one',
                    dstFactor: 'one-minus-src-alpha',
                    operation: 'add',
                },
            },
        }],
    },
    primitive: {
        topology: 'triangle-list',
    },
});
```

### Multiple Pipelines

Blit–Tech uses separate pipelines for different purposes:

1. **Primitives pipeline** - Colored vertices, no texture
2. **Sprites pipeline** - Textured quads with tint

Each pipeline has its own:

- Shader module
- Vertex buffer layout
- Bind group layout

## Performance Patterns

### Batching

Minimize draw calls by batching:

```typescript
// Bad - one draw call per sprite
for (const sprite of sprites) {
    renderPass.draw(6, 1, sprite.offset, 0);
}

// Good - batch all sprites with same texture
renderPass.draw(totalVertices, 1, 0, 0);
```

### State Changes

State changes are expensive. Minimize:

- Pipeline switches
- Bind group changes
- Texture binds

Sort draw calls by state when possible:

```typescript
// Sort sprites by texture before batching
sprites.sort((a, b) => a.texture.id - b.texture.id);
```

### Texture Atlases

Prefer texture atlases over individual textures:

- Single bind group for all sprites
- No texture switching mid-batch
- Better GPU cache utilization

### Multi-Texture Batching

When texture atlases aren't possible, queue batches:

```typescript
interface SpriteBatch {
    texture: GPUTexture;
    vertices: Float32Array;
    count: number;
}

// Queue batches, render in order
private spriteBatches: SpriteBatch[] = [];
```

## Error Handling

### Device Lost

Handle GPU device loss gracefully:

```typescript
device.lost.then((info) => {
    console.error('WebGPU device lost:', info.message);
    if (info.reason !== 'destroyed') {
        // Attempt recovery - reinitialize
        this.initialize();
    }
});
```

### Validation Errors

Enable validation in development:

```typescript
const adapter = await navigator.gpu.requestAdapter();
const device = await adapter.requestDevice({
    // Validation enabled by default in dev
});

device.onuncapturederror = (event) => {
    console.error('WebGPU error:', event.error.message);
};
```

### Feature Detection

Check for WebGPU support:

```typescript
if (!navigator.gpu) {
    throw new Error('WebGPU not supported in this browser');
}

const adapter = await navigator.gpu.requestAdapter();
if (!adapter) {
    throw new Error('No WebGPU adapter available');
}
```

## Memory Management

### Resource Cleanup

Destroy GPU resources when done:

```typescript
class SpriteSheet {
    private texture: GPUTexture | null = null;

    destroy(): void {
        if (this.texture) {
            this.texture.destroy();
            this.texture = null;
        }
    }
}
```

### Bind Group Caching

Cache bind groups to avoid recreation:

```typescript
private bindGroupCache = new Map<GPUTexture, GPUBindGroup>();

getBindGroup(texture: GPUTexture): GPUBindGroup {
    let bindGroup = this.bindGroupCache.get(texture);
    if (!bindGroup) {
        bindGroup = this.createBindGroup(texture);
        this.bindGroupCache.set(texture, bindGroup);
    }
    return bindGroup;
}
```

## Frame Lifecycle

Standard frame structure:

```typescript
beginFrame(): void {
    // Reset counters
    this.primitiveVertexCount = 0;
    this.spriteVertexCount = 0;
    this.spriteBatches = [];
}

// ... drawing calls accumulate vertices ...

endFrame(): void {
    // Upload vertex data
    device.queue.writeBuffer(this.vertexBuffer, 0, this.vertexData);

    // Begin render pass
    const encoder = device.createCommandEncoder();
    const pass = encoder.beginRenderPass(renderPassDescriptor);

    // Draw primitives
    pass.setPipeline(this.primitivesPipeline);
    pass.draw(this.primitiveVertexCount, 1, 0, 0);

    // Draw sprite batches
    pass.setPipeline(this.spritesPipeline);
    for (const batch of this.spriteBatches) {
        pass.setBindGroup(1, this.getBindGroup(batch.texture));
        pass.draw(batch.count, 1, batch.offset, 0);
    }

    pass.end();
    device.queue.submit([encoder.finish()]);
}
```